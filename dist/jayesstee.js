var jst =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/jayesstee.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://jst/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/jayesstee.js":
/*!**************************!*\
  !*** ./src/jayesstee.js ***!
  \**************************/
/*! exports provided: jst, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"jst\", function() { return jst; });\n/* harmony import */ var _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jst-utils.js */ \"./src/jst-utils.js\");\n/* harmony import */ var _jst_component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jst-component.js */ \"./src/jst-component.js\");\n/* harmony import */ var _jst_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jst-element.js */ \"./src/jst-element.js\");\n/* harmony import */ var _jst_style_manager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jst-style-manager.js */ \"./src/jst-style-manager.js\");\n/* harmony import */ var _jst_form_manager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jst-form-manager.js */ \"./src/jst-form-manager.js\");\n// Jayesstee (JST) is a pure javascript HTML templating\n// library, that lets you build HTML (and insert into the DOM)\n// using functional javascript \n//\n// Copyright 2018 Edward Funnekotter All rights reserved\n\n\n\n\n\n\n\n\n\n\nfunction jst(selectorOrElement) {\n  if (selectorOrElement instanceof HTMLElement) {\n    return new _jst_element_js__WEBPACK_IMPORTED_MODULE_2__[\"JstElement\"](selectorOrElement);\n  }\n  else {\n    let el = document.querySelector(selectorOrElement);\n    if (!el) {\n      return new _jst_element_js__WEBPACK_IMPORTED_MODULE_2__[\"JstElement\"]();\n    }\n    else {\n      return new _jst_element_js__WEBPACK_IMPORTED_MODULE_2__[\"JstElement\"](el);\n    }\n  }\n}\n \n/* harmony default export */ __webpack_exports__[\"default\"] = (jst);\n\n\njst.fn = jst.prototype = {};\n\n\n// Shrunken version of jQuery's extend\njst.extend = jst.fn.extend = function() {\n  let target = this;\n  let length = arguments.length;\n\n  for (let i = 0; i < length; i++) {\n    let options;\n    if ((options = arguments[i]) !== null) {\n      for (let name in options) {\n        let copy = options[name];\n\n        // Prevent never-ending loop\n        if (target === copy) {\n          continue;\n        }\n\n        if (copy !== undefined) {\n          target[name] = copy;\n        }\n      }\n    }\n  }\n\n  // Return the modified object\n  return target;\n};\n\n\njst.extend({\n  debug:     false,\n  tagPrefix: \"$\",\n  Object:    _jst_component_js__WEBPACK_IMPORTED_MODULE_1__[\"JstComponent\"],\n  Component: _jst_component_js__WEBPACK_IMPORTED_MODULE_1__[\"JstComponent\"],\n  Form:      _jst_form_manager_js__WEBPACK_IMPORTED_MODULE_4__[\"JstFormManager\"],\n  Element:   _jst_element_js__WEBPACK_IMPORTED_MODULE_2__[\"JstElement\"],\n  tags: [\n    'a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base',\n    'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption',\n    'cite', 'code', 'col', 'colgroup', 'command', 'data', 'datalist', 'dd',\n    'del', 'details', 'dfn', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset',\n    'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5',\n    'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input',\n    'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'math',\n    'menu', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option',\n    'output', 'p', 'param', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's',\n    'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong',\n    'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'textarea',\n    'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var',\n    'video', 'wbr','altGlyph','altGlyphDef','altGlyphItem','animate','animateColor','animateMotion',\n    'animateTransform','circle','clipPath','color-profile','cursor','defs','desc','discard',\n    'ellipse','feBlend','feColorMatrix','feComponentTransfer','feComposite','feConvolveMatrix',\n    'feDiffuseLighting','feDisplacementMap','feDistantLight','feDropShadow','feFlood','feFuncA',\n    'feFuncB','feFuncG','feFuncR','feGaussianBlur','feImage','feMerge','feMergeNode','feMorphology',\n    'feOffset','fePointLight','feSpecularLighting','feSpotLight','feTile','feTurbulence','filter',\n    'font','font-face','font-face-format','font-face-name','font-face-src','font-face-uri',\n    'foreignObject','g','glyph','glyphRef','hatch','hatchpath','hkern','image','line',\n    'linearGradient','marker','mask','mesh','meshgradient','meshpatch','meshrow','metadata',\n    'missing-glyph','mpath','path','pattern','polygon','polyline','radialGradient','rect','script',\n    'set','solidcolor','stop','style','svg','switch','symbol','text','textPath','title','tref',\n    'tspan','unknown','use','view','vkern'\n  ],\n  cssFuncs: [\n    'attr', 'calc', 'cubic-bezier', 'hsl', 'hsla', 'linear-gradient',\n    'radial-gradient', 'repeating-linear-gradient', 'repeating-radial-gradient',\n    'rgb', 'rgba', 'var', 'translate', 'matrix', 'matrix3d', 'translate', 'translate3d',\n    'translateX', 'translateY', 'translateZ', 'scale', 'scale3d', 'scaleX', 'scaleY',\n    'scaleZ', 'rotate', 'rotate3d', 'rotateX', 'rotateY', 'rotateZ', 'skew', 'skewX',\n    'skewY', 'perspective'\n  ],\n  cssUnits: [\n    'cm', 'mm', 'in', 'px', 'pt', 'pc', 'em', 'ex', 'ch', 'rem', 'vw', 'vh',\n    'vmin', 'vmax', 'deg', 'rad', 's'\n  ],\n  \n  // If there are some new elements that you want to insert into the DOM that\n  // aren't in the hardcoded list above, then you can add them with this\n  // (raise a github issue too, so they can be added to the list if they are\n  // generally useful)\n  addCustomElements: function() {\n    let names = _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"]._flatten.apply(this, arguments);\n\n    for (let name of names) {\n      let fullName = jst.tagPrefix + name;\n      jst[fullName] = function() {\n        let args = _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"]._flatten.apply(this, arguments);\n        return (new _jst_element_js__WEBPACK_IMPORTED_MODULE_2__[\"JstElement\"](name, args));\n      };\n    }\n  },\n\n  addCssFunctions: function() {\n    let names = _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"]._flatten.apply(this, arguments);\n    for (let name of names) {\n      let camelName = name.replace(/-([a-z])/g, match => match[1].toUpperCase());\n      jst[camelName] = function() {\n        let args = _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"]._flatten.apply(this, arguments);\n        return `${name}(${args.join(\",\")})`;\n      };\n    }\n  },\n\n  addCssUnits: function() {\n    let names = _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"]._flatten.apply(this, arguments);\n    for (let name of names) {\n      jst[name] = function() {\n        let args = _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"]._flatten.apply(this, arguments);\n        let fixed = args.map(arg => `${arg}${name}`);\n        return fixed.join(\" \") + \" \";\n      };\n    }\n  },\n\n  // Used to associate a generic object with JST so that it can be used\n  // as a refreshable datasource for a template\n  object: function(obj) {\n    if (typeof(obj) != \"object\") {\n      throw(new Error(\"You must pass an object to jst.object()\"));\n    }\n    return obj.$jst = new _jst_component_js__WEBPACK_IMPORTED_MODULE_1__[\"JstComponent\"](obj);\n  },\n\n  // Put all the element functions (e.g. $div(), $span()) in the global (window)\n  // namespace\n  makeGlobal: function(prefix) {\n    jst.global          = true;\n    jst.globalTagPrefix = prefix || jst.tagPrefix;\n    for (let tag of jst.tags) {\n      let name = jst.globalTagPrefix + tag;\n      let g = typeof global !== 'undefined' ? global : window;\n      g[name] = function() {\n        return jst[name].apply(this, arguments);\n      };\n    }\n  },\n\n  // Check passed in value to see if it is of interest in the following way:\n  //   - is it defined at all?\n  //   - if it is an array, does it have any values?\n  //   - if it is an object, does it have properties?\n  //   - if it is a number, always return true\n  // If the checks fail, then return ifFalse or undefined, otherwise return ifTrue || true\n  //\n  // This can be used to prefix rendering blocks with jst.if(val) && ..., e.g.:\n  //    render() {\n  //      // this works because 'undefined' is silently skipped in Jayesstee\n  //      return jst.if(myList) && jst.$ul(myList.map(item => jst.$li(item)))\n  //    }\n  // or if you prefer, you can do a tertiary expression: jst.if(val) ? ... : ...\n  //\n  // Note that if you pass in a boolean, 'false' will return 'undefined' and 'true'\n  // will return 'true'\n  if: function(val, ifTrue, ifFalse) {\n    ifTrue = ifTrue || true;\n    let type = typeof(val);\n    if (type === \"number\") {\n      return ifTrue;\n    }\n    if (type === \"undefined\" || val === null) {\n      return ifFalse;\n    }\n    if (Array.isArray(val)) {\n      return val.length ? ifTrue : ifFalse;\n    }\n    if (type === \"object\") {\n      return Object.keys(val).length === 0 && val.constructor === Object ? ifFalse : ifTrue;\n    }\n\n    // Catch all including boolean type\n    return val ? ifTrue : ifFalse;\n    \n  },\n\n  // Control debug behaviour - with debug on, jayesstee will include\n  // additional elements in the DOM to make it much easier to debug the\n  // heirarchy\n  setDebug: function(val) {\n    jst.debug = val;\n  },\n\n  //\n  // Internal functions\n  //\n  // Called automatically\n  _init: function() {\n    _jst_element_js__WEBPACK_IMPORTED_MODULE_2__[\"JstElement\"].init(jst);\n    _jst_component_js__WEBPACK_IMPORTED_MODULE_1__[\"JstComponent\"].init(jst);\n    jst.addCustomElements(jst.tags);\n    jst.addCssFunctions(jst.cssFuncs);\n    jst.addCssUnits(jst.cssUnits);\n    jst.styleManager = new _jst_style_manager_js__WEBPACK_IMPORTED_MODULE_3__[\"JstStyleManager\"]();\n    if (typeof window !== 'undefined') {\n      jst(\"head\").appendChild(jst.styleManager);\n    }\n    else {\n      global.HTMLElement = class HTMLElement {};\n    }\n  },\n\n  \n\n});\n\njst._init();\n\n\n// Debug stuff\n\njst.print = (jstEl, level) => {\n  level = level || 0;\n  let indent = \" \".repeat(level*2);\n\n  let text = indent + `${jstEl.tag} ${jstEl.id}:\\n`;\n  text    += indent + `  attrs: ${Object.keys(jstEl.attrs).length}\\n`;\n  text    += indent + `  props: ${jstEl.props.length}\\n`;\n  text    += indent + `  events: ${Object.keys(jstEl.events).length}\\n`;\n  text    += indent + `  hasEl: ${jstEl.el ? \"yes\" : \"no\"}\\n`;\n  text    += indent + `  hasParentEl: ${jstEl.el && jstEl.el.parentNode ? \"yes\" : \"no\"}\\n`;\n\n  jstEl.contents.forEach(item => {\n    if (item.type === _jst_element_js__WEBPACK_IMPORTED_MODULE_2__[\"JstElementType\"].JST_ELEMENT) {\n      text += jst.print(item.value, level+1);\n    }\n    else if (item.type === _jst_element_js__WEBPACK_IMPORTED_MODULE_2__[\"JstElementType\"].JST_COMPONENT && item.value._jstEl) {\n      text += indent + `    Component ${item.value.constructor.name}\\n`;\n      text += jst.print(item.value._jstEl, level+2);\n    }\n    else if (item.type === _jst_element_js__WEBPACK_IMPORTED_MODULE_2__[\"JstElementType\"].TEXTNODE) {\n      text += indent + `    Text: ${item.value}\\n`;\n    }\n  });\n\n  if (level == 0) {\n    console.log(text);\n  }\n  \n  return text;\n  \n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://jst/./src/jayesstee.js?");

/***/ }),

/***/ "./src/jst-component.js":
/*!******************************!*\
  !*** ./src/jst-component.js ***!
  \******************************/
/*! exports provided: JstComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JstComponent\", function() { return JstComponent; });\n/* harmony import */ var _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jst-utils.js */ \"./src/jst-utils.js\");\n/* harmony import */ var _jst_element_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jst-element.js */ \"./src/jst-element.js\");\n/* harmony import */ var _jst_form_manager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jst-form-manager.js */ \"./src/jst-form-manager.js\");\n\n\n\n\n\n\n// Some global unique identifiers\n\n// Tracks the JstComponent ID (ever increasing)\nlet globalJstComponentId       = 1;\n\n// Tracks the JstComponent's Class ID\nlet globalJstComponentClassId  = 1;\n\n// Reference to global JST\nlet jst;\n\n// JstComponent Class\n//\n// This class is a base class for all classes that are\n// renderable within jayesstee. For a user-defined class to\n// be successfully redered, it must extend this class and\n// implement the render() method\n//\n// It can also be used as a companion object for generic\n// objects. Calling jst.object(someObj) will return one of these\n// objects that is linked to someObj (someObj.$jst is this object and\n// this.companionObj is the passed in object).\nclass JstComponent {\n  static init(jstInit) {\n    jst = jstInit;\n  }\n\n  constructor(companionObj) {\n    this._jstId           = globalJstComponentId++;\n    this._companionObj    = companionObj;\n    this._renderFunc      = undefined;\n    this._forms           = {};\n    this._wasRendered     = false;\n    this._jstEl           = undefined;\n    this._refCount        = 0;\n    this.updateWithParent = false;\n\n    // TODO - there must be a better way to do this\n    // Note that orginally, it just stored the _jstClassId directly\n    // on this.constructor.prototype, but that resulted in parent classes ending up\n    // with the same ID as the child (e.g. InputButton -> Input -> JstComponent,\n    // InputButton and Input got the same ID)\n    if (!this.constructor.prototype._jstClassIds) {\n      this.constructor.prototype._jstClassIds = {};\n    }\n    if (!this.constructor.prototype._jstClassIds[this.constructor.name]) {\n      this.constructor.prototype._jstClassIds[this.constructor.name] = globalJstComponentClassId++;\n    }\n\n    this._jstClassId = this.constructor.prototype._jstClassIds[this.constructor.name];\n\n    this._classPrefix     = `jsto${this._jstClassId}-`;\n    this._fullPrefix      = `jsto${this._jstClassId}-i${this._jstId}-`;\n    this._type            = `${this.getName()}-${this.getFullPrefix()}`;\n\n  }\n\n  destroy() {\n    jst.styleManager.removeCss(this);\n  }\n\n  // Refresh the instantiation of this object\n  // Should be called after dependent data is changed\n  refresh(opts) {\n\n    let isParentUpdate = opts ? opts.isParentUpdate : false;\n    \n    if (!isParentUpdate && !this._jstEl) {\n      return;\n    }\n    \n    // Gather all the styles for this object\n    let css     = this.renderCss(opts);\n    if (css) {\n      jst.styleManager.updateCss(this, css);\n    }\n\n    this._refCount++;\n    // console.warn(\"refresh:\", this._type, this._refCount);\n    if (!this._jstEl && isParentUpdate ||\n        (isParentUpdate && this.updateWithParent) ||\n        !isParentUpdate\n       ) {\n    \n      // Create a new JST tree that will be compared against the existing one\n      let items   = this._render();\n\n      // newJst will contain the new updated tree\n      let newJst = new _jst_element_js__WEBPACK_IMPORTED_MODULE_1__[\"JstElement\"](\"jstobject\", [{type: this.getType()}]);\n      newJst._processParams([items], true);\n\n      if (this._jstEl){\n        // Compare with the existing tree to find what needs to change\n        this._jstEl._compareAndCopy(newJst, true, this, false, 0);\n        // Need to call unrender to decrement the refcount for the temp\n        // object\n        this._unrender();\n      }\n      else {\n        this._jstEl = newJst;\n      }\n      \n      // If we were already domified, then redo it for the new elements\n      if (this._jstEl.isDomified) {\n        this._jstEl.dom(this);\n      }\n\n      Promise.resolve().then(() => this._postRender());\n      \n    }\n    \n  }\n\n  html() {\n    if (this._jstEl) {\n      return this._jstEl.html();\n    }\n    else {\n      this.refresh({isParentUpdate: true});\n      return this._jstEl.html();\n    }\n  }\n\n  // Internally called render function - will call publically\n  // available one \n  _render() {\n    let items = this.render();\n    this._wasRendered = true;\n    return items;\n  }\n\n  // Called automatically on instantiation or refresh\n  // This must be overrided in classes inheriting from JstComponent\n  render() {\n    if (!this._renderFunc) {\n      if (this._companionObj) {\n        throw(new Error(\"You must define a render function with .fill()\"));\n      }\n      else {\n        throw(new Error(\"You must override render() in descendant classes\"));\n      }\n    }\n    else {\n      return this._renderFunc(this._companionObj);\n    }\n  }\n\n  // Internally called postRender function\n  _postRender() {\n    this.postRender();\n  }\n\n  // Empty base class for postRender - sub classes can override\n  postRender() {\n  }\n\n  // Called when a parent no longer wants this object's tree in the DOM\n  _unrender() {\n    this._refCount--;\n    // console.warn(\"unrender:\", this._type, this._refCount);\n    if (this._refCount < 0) {\n      throw new Error(\"Invalid ref count in jstobject\", this);\n    }\n    if (this._refCount == 0) {\n      this.unrender();\n      if (this._jstEl) {\n        this._jstEl.delete();\n        delete(this._jstEl);\n      }\n      this.destroy();\n    }\n  }\n\n  // Can be overrided in the sub class \n  unrender() {\n  }\n\n  // Called automatically on instantiation or full refresh\n  renderCss() {\n    let css = {};\n    let someCss = false;\n    for (let type of ['cssGlobal', 'cssLocal', 'cssInstance']) {\n      if (this[type]) {\n        let rawCss = this[type]();\n        if (rawCss) {\n          css[type] = this._normalizeCss(rawCss);\n          someCss = true;\n        }\n      }\n    }\n    return someCss ? css : undefined;\n  }\n\n  getWasRendered() {\n    return this._wasRendered;\n  }\n\n  getClassPrefix() {\n    return this._classPrefix;\n  }\n\n  getFullPrefix() {\n    return this._fullPrefix;\n  }\n\n  getUpdateWithParent() {\n    return this.updateWithParent;\n  }\n\n  // Used to specify the render behaviour for a generic object that\n  // has been linked through jst.object(<object>)\n  fill(renderFunc) {\n    if (typeof(renderFunc) !== \"function\") {\n      throw(new Error(\".fill() expects a function to be passed in\"));\n    }\n\n    this._renderFunc = renderFunc;\n    \n    return this;\n  }\n\n  getName() {\n    return this.constructor.name;\n  }\n\n  getType() {\n    return this._type;\n  }\n\n  addForm(jstElement) {\n    let name = jstElement.attrs.name || jstElement.attrs.id || \"_unnamed_\";\n\n    if (this._forms[name]) {\n      this._forms[name].setJstElement(jstElement);\n    }\n    else {\n      this._forms[name] = new _jst_form_manager_js__WEBPACK_IMPORTED_MODULE_2__[\"JstFormManager\"](jstElement);\n    }\n    return this._forms[name];\n  }\n\n  getFormValues(name) {\n    let form = this._forms[name || \"_unnamed_\"];\n    return form ? form.getValues() : {};\n  }\n\n  // Internal function to record the reference name\n  setRef(refName, val) {\n    if (this._companionObj) {\n      this._companionObj[refName] = val;\n    }\n    else {\n      this[refName] = val;\n    }\n  }\n\n  // Get file, line and column info\n  _getCodeLocation() {\n    \n  }\n\n  _normalizeCss(input) {\n    // First flatten the top level\n    let flat = _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"]._flatten(input);\n    let evenFlatter = [];\n    \n    // We should now have a single array that could have objects or values\n    flat.map(entry => {\n      if (entry instanceof Object) {\n        evenFlatter = evenFlatter.concat(jst._normalizeCssObject(entry));\n      }\n      else {\n        evenFlatter.push(entry);\n      }\n    });\n    return evenFlatter;\n  }\n\n  _normalizeCssObject(obj) {\n    const atRules = new Set([\"$media\", \"$keyframes\", \"$supports\", \"$page\",\n                             \"$fontFace\", \"$viewport\", \"$counterStyle\",\n                             \"$fontFeatureValues\", \"$swash\", \"$ornaments\",\n                             \"$stylistic\", \"$styleset\", \"$characterVariant\"]);\n    let fixed = [];\n    \n    for (let prop of Object.keys(obj)) {\n\n      let sel;\n      let fixedSetting = {};\n      \n      if (atRules.has(prop)) {\n        let processed = this._normalizeCssObject(obj[prop]);\n        sel = prop.replace(/^\\$/, \"@\").replace(/([A-Z])/g, m => \"-\"+m.toLowerCase());\n        processed.map(item => fixedSetting = Object.assign(fixedSetting, item));\n      }\n      else {\n        \n        let parts = prop.split(\"$\");\n        sel       = parts.shift();\n        for (let part of parts) {\n          if (part === \"c\") {\n            sel = `.${sel}`;\n          }\n          else if (part === \"i\") {\n            sel = `#${sel}`;\n          }\n          else {\n            sel = `${sel}:${part}`;\n          }\n        }\n\n        \n        let setting = _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"]._flatten(obj[prop]);\n        setting.map(val => {\n          if (val instanceof Object) {\n            fixedSetting = Object.assign(fixedSetting, jst._normalizeCssStyles(val));\n          }\n          else {\n            fixedSetting = val;\n          }\n        });\n\n      }\n      \n      let tmpObj = {};\n      tmpObj[sel] = fixedSetting;\n      fixed.push(tmpObj);\n    }\n    return fixed;\n  }\n\n  _normalizeCssStyles(obj) {\n    let fixed = {};\n    for (let prop of Object.keys(obj)) {\n      let val = obj[prop];\n      if (val instanceof Object && !Array.isArray(val)) {\n        if (val.rgb && val.rgb().string) {\n          fixed[prop] = val.rgb().string();\n        }\n        else {\n          let fixedObj = this._normalizeCssStyles(obj[prop]); \n          fixed[prop] = [fixedObj];\n        }\n      }\n      else {\n        let val   = _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"]._flatten(obj[prop]);\n        let match = prop.match(/^([^$]+)\\$(.+)/);\n        if (match) {\n          val = val.map(item => jst._addCssUnit(match[2], item));\n          fixed[match[1]] = val;\n        }\n        else {\n          fixed[prop] = val;\n        }\n      }\n    }\n    return fixed;\n  }\n\n  _addCssUnit(unit, val) {\n    if (typeof(val) === \"number\") {\n      return `${val}${unit || \"\"}`;\n    }\n    return val && val.toString ? val.toString() : val;\n  }\n\n  \n}\n\n\n//# sourceURL=webpack://jst/./src/jst-component.js?");

/***/ }),

/***/ "./src/jst-element.js":
/*!****************************!*\
  !*** ./src/jst-element.js ***!
  \****************************/
/*! exports provided: JstElementType, JstElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JstElementType\", function() { return JstElementType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JstElement\", function() { return JstElement; });\n/* harmony import */ var _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jst-utils.js */ \"./src/jst-utils.js\");\n/* harmony import */ var _jst_component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jst-component.js */ \"./src/jst-component.js\");\n// jst-element - this file contains the implementation\n// of the JstElement class. This class represents an HTML element.\n// On creation it is just a scaffold that can be either inserted into\n// the DOM (in a browser) or serialized into HTML.\n//\n// Copyright 2018 Edward Funnekotter All rights reserved\n\n\n\n\n\n\n// Ever increasing ID for each element\nlet globalJstElementId      = 1;\n\n// Global reference to the parent\nlet jst;\n\n// Valid JstElement types\nconst JstElementType = {\n  INVALID:        0,\n  JST_ELEMENT:    1,\n  JST_COMPONENT:  2,\n  TEXTNODE:       3,\n  HTML_ELEMENT:   4  \n};\n\n\n// The class definition\nclass JstElement {\n\n  // Called from jayesstee during its init\n  static init(jstInit) {\n    jst = jstInit;\n  }\n\n  \n  constructor(tagOrEl, params) {\n    this.id         = globalJstElementId++;\n    this.contents   = [];\n    this.attrs      = {};\n    this.props      = [];\n    this.events     = {};\n    this.opts       = {};\n    this._refCount  = 0;\n\n    if (tagOrEl instanceof HTMLElement) {\n      // Wrapping an element with a JstElement\n      this.tag = tagOrEl.tagName.toLowerCase();\n      this.el  = tagOrEl;\n    }\n    else {\n      this.tag = tagOrEl.toLowerCase();\n    }\n\n    // Handle all contained items in this element\n    this._processParams(params);\n\n    if (this.el) {\n      // If we have a real element, put all the content into it\n      this.dom();\n    }\n  }\n\n  \n  // Takes the same parameters as a normal JstElement, but\n  // just adds them to the existing contents\n  appendChild() {\n    this.isDomified = false;\n\n    this._processParams(arguments);\n    if (this.el) {\n      this.dom();\n    }\n  }\n\n  \n  // Takes the same parameters as a normal JstElement and\n  // replaces the existing contents with them\n  replaceChild() {\n    if (this.el) {\n      this.el.innerHTML = \"\";\n    }\n\n    this.isDomified = false;\n    this.contents   = [];\n    this.atts       = [];\n    this.props      = [];\n\n    this.appendChild.apply(this, arguments);\n  }\n\n\n  // Serialize this element (and sub-elements) into HTML\n  html(opts, lastJstComponent) {\n    let html = \"\";\n\n    if (!opts)       { opts = {}; }\n    if (!opts.depth) { opts.depth = 0; }\n\n    if (jst.debug || this.tag !== \"jstobject\") {\n      \n      if (opts.indent) {\n        html += \" \".repeat(opts.indent * opts.depth++);\n      }\n\n      html += \"<\" + this.tag;\n\n      let attrs = [];\n      for (let attrName of Object.keys(this.attrs)) {\n        let val = this.attrs[attrName];\n        if (lastJstComponent && (attrName === \"class\" || attrName === \"id\") && val.match && val.match(/(^|\\s)-/)) {\n          val = val.replace(/(^|\\s)(--?)/g, (m, p1, p2) => p1 + (p2 === \"-\" ? lastJstComponent.getClassPrefix() : lastJstComponent.getFullPrefix()));\n        }\n        attrs.push(attrName + \"=\" + \"\\\"\" + this._quoteAttrValue(val) + \"\\\"\");\n      }\n      if (attrs.length) {\n        html += \" \" + attrs.join(\" \");\n      }\n      if (this.props.length) {\n        html += \" \" + this.props.join(\" \");\n      }\n\n      html += \">\";\n\n      if (opts.indent) {\n        html += \"\\n\";\n      }\n    }\n    \n    this._visitContents(lastJstComponent, (jstComponent, item) => {\n\n      // A contained JstElement\n      if (item.type === JstElementType.JST_ELEMENT) {\n        html += item.value.html(opts, jstComponent);\n      }\n\n      // A contained HTMLElememnt\n      else if (item.type === JstElementType.HTML_ELEMENT) {\n        html += item.value.innerHTML;\n      }\n\n      // Text node\n      else if (item.type === JstElementType.TEXTNODE) {\n        if (opts.indent && opts.depth) {\n          html += \" \".repeat(opts.indent * opts.depth);\n        }\n        html += item.value;\n        if (opts.indent && opts.depth) {\n          html += \"\\n\";\n        }\n      }\n      else {\n        console.warn(\"Unexpected content type while serializing:\", item.type);\n      }\n      \n    });\n\n    if (opts.indent && opts.depth) {\n      opts.depth--;\n      html += \" \".repeat(opts.indent * opts.depth);\n    }\n\n    if (jst.debug || this.tag !== \"jstobject\") {\n      html += `</${this.tag}>`;\n      if (opts.indent) {\n        html += \"\\n\";\n      }\n    }\n    \n    return html;\n  }\n\n  \n  // Instantiate into the DOM and return the HTMLElement\n  //   Optional arguments:\n  //      lastJstComponent - reference to the JstComponent containing this element\n  //      lastJstForm      - reference to the JstForm containing this element \n  dom(lastJstComponent, lastJstForm) {\n    // console.warn(\"Domming:\", this.tag, this.attrs.class, lastJstComponent);\n\n    // TEMP protection...\n    if (this.tag === \"-deleted-\") {\n      console.error(\"Trying to DOM a deleted element\", this);\n      return undefined;\n    }\n    let el = this.el || document.createElement(this.tag);\n\n    // If the element parameters contains a 'ref' attribute, then fill it in\n    if (this.ref && lastJstComponent) {\n      lastJstComponent.setRef(this.ref, this);\n    }\n\n    // Handle forms\n    if (lastJstComponent && this.tag === \"form\" && (this.attrs.name || this.attrs.id)) {\n      lastJstForm = lastJstComponent.addForm(this);\n    }\n    else if (lastJstForm &&\n             (this.tag === \"input\" ||\n              this.tag === \"textarea\" ||\n              this.tag === \"select\")) {\n      lastJstForm.addInput(this);\n    }\n\n    if (!this.isDomified) {\n      \n      this.jstComponent = lastJstComponent;\n\n      // Handle all the attributes on this element\n      for (let attrName of Object.keys(this.attrs)) {\n        let val = this.attrs[attrName];\n\n        // Special case for 'class' and 'id' attributes. If their values start with\n        // '-' or '--', add the scope to their values\n        if (lastJstComponent && (attrName === \"class\" || attrName === \"id\") &&\n            val.match && val.match(/(^|\\s)-/)) {\n          val = val.replace(/(^|\\s)(--?)/g,\n                            (m, p1, p2) => p1 +\n                            (p2 === \"-\" ? lastJstComponent.getClassPrefix() :\n                                          lastJstComponent.getFullPrefix()));\n        }\n        el.setAttribute(attrName, val);\n      }\n\n      // Add the properties\n      for (let propName of this.props) {\n        el[propName] = true;\n      }\n\n      // Add event listeners\n      for (let event of Object.keys(this.events)) {\n        // TODO: Add support for options - note that this will require\n        //       some detection of options support in the browser...\n        el.addEventListener(event, this.events[event].listener);\n      }\n      \n      // Now add all the contents of the element\n      this._visitContents(lastJstComponent, (jstComponent, item) => {\n\n        if (item.type === JstElementType.TEXTNODE) {\n          if (!item.el) {\n            item.el = document.createTextNode(item.value);\n            el.appendChild(item.el);\n          }\n        }\n        else if (item.type === JstElementType.JST_ELEMENT) {\n          let hasEl   = item.value.el; \n          let childEl = item.value.dom(jstComponent, lastJstForm);\n          if (!hasEl) {\n            el.appendChild(childEl);\n          }\n          else if (childEl.parentNode && childEl.parentNode !== el) {\n            childEl.parentNode.removeChild(childEl);\n            el.appendChild(childEl);\n          }\n        }\n        else {\n          console.error(\"Unexpected contents item type:\", item.type);\n        }\n        \n      });\n\n    }\n\n    this.el         = el;\n    this.isDomified = true;\n    return el;\n\n  }\n\n  // Delete this element and remove from the DOM if there\n  delete() {\n\n    this._refCount--;\n\n    if (this._refCount <= 0) {\n      // Remove all items associated with this JstElement\n      for (let item of this.contents) {\n        this._deleteItem(item);\n      }\n\n      // Remove any reference to the JstComponent (circular reference)\n      delete this.jstComponent;\n\n      // Delete this element, if present\n      if (this.el) {\n        if (this.el.parentNode) {\n          this.el.parentNode.removeChild(this.el);\n        }\n      }\n\n      delete this.el;\n\n      this.tag      = \"-deleted-\";\n      this.contents = [];\n      this.attrs    = {};\n      this.props    = [];\n    }\n    \n  }\n\n  // Add the element to a parent\n  add() {\n    this._refCount++;\n  }\n\n  // Takes a new Jst tree and will do a full comparison to find the differences\n  // which will then be copied into the real tree in preparation for changing\n  // the DOM \n  // Returns true if upper layer needs to copy new Jst. False otherwise\n  _compareAndCopy(newJst, topNode, jstComponent, forceUpdate, level) {\n    let oldIndex = 0;\n    let newIndex = 0;\n\n    // console.log(\"CAC>\" + \" \".repeat(level*2), this.tag + this.id, newJst.tag+newJst.id);\n    \n    // First check the attributes, props and events\n    // But only if we aren't the topNode\n    if (!topNode) {\n      if (forceUpdate || this.opts.forceUpdate || this.tag !== newJst.tag) {\n        return true;\n      }\n\n      // Blindly copy the JST options\n      this.opts = newJst.opts;\n      \n      // Just fix all the attributes inline\n      for (let attrName of Object.keys(this.attrs)) {\n        if (!newJst.attrs[attrName]) {\n          delete this.attrs[attrName];\n          if (this.isDomified) {\n            this.el.removeAttribute(attrName);\n          }\n        }\n        else if (newJst.attrs[attrName] !== this.attrs[attrName]) {\n          this.attrs[attrName] = newJst.attrs[attrName];\n          if (this.isDomified) {\n            //refactor\n            let val = newJst.attrs[attrName];\n            if (this.jstComponent && (attrName === \"class\" || attrName === \"id\") &&\n                val.match(/(^|\\s)-/)) {\n              // Add scoping for IDs and Class names\n              val = val.replace(/(^|\\s)(--?)/g,\n                                (m, p1, p2) => p1 + (p2 === \"-\" ?\n                                                     this.jstComponent.getClassPrefix() :\n                                                     this.jstComponent.getFullPrefix()));\n            }\n            this.el.setAttribute(attrName, val);\n          }\n        }\n      }\n      for (let attrName of Object.keys(newJst.attrs)) {\n        if (!this.attrs[attrName]) {\n          this.attrs[attrName] = newJst.attrs[attrName];\n          if (this.isDomified) {\n            //refactor\n            let val = newJst.attrs[attrName];\n            if (this.jstComponent && (attrName === \"class\" || attrName === \"id\") &&\n                val.match(/(^|\\s)-/)) {\n              // Add scoping for IDs and Class names\n              val = val.replace(/(^|\\s)(--?)/g,\n                                (m, p1, p2) => p1 + (p2 === \"-\" ?\n                                                     this.jstComponent.getClassPrefix() :\n                                                     this.jstComponent.getFullPrefix()));\n            }\n            this.el.setAttribute(attrName, val);\n          }\n        }\n      }\n\n      if (this.props.length || newJst.props.length) {\n        let fixProps = false;\n        \n        // Just compare them in order - if they happen to be the same,\n        // but in a different order, we will do a bit more work than necessary\n        // but it should be very unlikely that that would happen\n        if (this.props.length != newJst.props.length) {\n          fixProps = true;\n        }\n        else {\n          for (let i = 0; i < this.props.length; i++) {\n            if (this.props[i] !== newJst.props[i]) {\n              fixProps = true;\n              break;\n            }\n          }\n        }\n        \n        if (fixProps) {\n          if (this.isDomified) {\n            for (let prop of this.props) {\n              delete this.el[prop];\n            }\n            for (let prop of newJst.props) {\n              this.el[prop] = true;\n            }\n          }\n          this.props = newJst.props;\n        }\n      }\n      \n      // Fix all the events\n      for (let eventName of Object.keys(this.events)) {\n        if (!newJst.events[eventName]) {\n          if (this.isDomified) {\n            this.el.removeEventListener(eventName, this.events[eventName].listener);\n          }\n          delete this.events[eventName];\n        }\n        else if (newJst.events[eventName].listener !== this.events[eventName].listener) {\n          if (this.isDomified) {\n            this.el.removeEventListener(eventName, this.events[eventName].listener);\n            this.el.addEventListener(eventName, newJst.events[eventName].listener);\n          }\n          this.events[eventName] = newJst.events[eventName];\n        }\n      }\n      for (let eventName of Object.keys(newJst.events)) {\n        if (!this.events[eventName]) {\n          this.events[eventName] = newJst.events[eventName];\n          if (this.isDomified) {\n            this.el.addEventListener(eventName, newJst.events[eventName].listener);\n          }\n        }\n      }\n      \n    }\n\n    if (!forceUpdate && !this.opts.forceUpdate) {\n      // Loop through the contents of this element and compare\n      // to the contents of the newly created element\n      while (true) {\n        let oldItem = this.contents[oldIndex];\n        let newItem = newJst.contents[newIndex];\n\n        if (!oldItem || !newItem) {\n          break;\n        }\n\n        // Types of items in the contents must match or don't continue\n        if (oldItem.type !== newItem.type) {\n          break;\n        }\n\n        if (oldItem.type === JstElementType.JST_ELEMENT) {\n\n          // Don't continue if the ID of the item has changed\n          // TODO - why does the refcount important here?\n          if (oldItem.id != this.id && this._refCount) {\n            break;\n          }\n          \n          // Descend into the JstElement and compare them\n          let doReplace = oldItem.value._compareAndCopy(newItem.value, false, undefined, undefined, level+1);\n          if (doReplace) {\n            break;\n          }\n          \n        }\n        else if (oldItem.type === JstElementType.JST_COMPONENT) {\n          // If the tags are the same, then we must descend and compare\n          if (oldItem.value._jstId != newItem.value._jstId) {\n            // Different JstComponents\n            break;\n          }\n\n          // Don't bother descending into JstComponents - they take care of themselves\n          \n        }\n        else if (oldItem.type === JstElementType.TEXTNODE && oldItem.value !== newItem.value) {\n\n          // For textnodes, we just fix them inline\n          if (oldItem.el) {\n            oldItem.el.textContent = newItem.value;\n          }\n          oldItem.value = newItem.value;\n        }\n\n        oldIndex++;\n        newIndex++;\n        \n        if (newItem.type === JstElementType.JST_COMPONENT) {\n          // Unhook this reference\n          newItem.value._unrender();\n        }\n      }\n    }\n\n    // Need to copy stuff - first delete all the old contents\n    let oldStartIndex = oldIndex;\n    let oldItem       = this.contents[oldIndex];\n    let itemsToDelete = [];\n\n    while (oldItem) {\n      // console.log(\"CAC>  \" + \" \".repeat(level*2), \"deleting old item :\", oldItem);\n      itemsToDelete.push(oldItem);\n      oldIndex++;\n      oldItem = this.contents[oldIndex];\n    }\n\n    // Remove unneeded items from the contents list\n    this.contents.splice(oldStartIndex, oldIndex - oldStartIndex);\n\n    if (newJst.contents[newIndex]) {\n\n      // Get list of new items that will be inserted\n      let newItems = newJst.contents.splice(newIndex, newJst.contents.length - newIndex);\n\n      // console.log(\"CAC>  \" + \" \".repeat(level*2), \"new items being added:\", newItems);\n\n      newItems.forEach(item => {\n        if (item.type === JstElementType.JST_ELEMENT) {\n          // TODO - needs some refactoring!\n          if (item.value.el && item.value.el.parentNode) {\n            item.value.el.parentNode.removeChild(item.value.el);\n            if (this.el) {\n              this.el.appendChild(item.value.el);\n            }\n            else {\n              delete(this.el);\n            }\n          }\n        }\n        else if (item.type === JstElementType.JST_COMPONENT) {\n          if (item.value._jstEl.el) {\n            if (item.value._jstEl.el.parentNode) {\n              item.value._jstEl.el.parentNode.removeChild(item.value._jstEl.el);\n              if (this.el) {\n                this.el.appendChild(item.value._jstEl.el);\n              }\n            }\n          }\n          else {\n            // Need to visit all the items for this component and hook them in\n            item.value._jstEl._visitContents(item.value, (jstComponent, subItem) => {\n              if (subItem.value) {\n                if (subItem.value.el) {\n                  if (subItem.value.el.parentNode) {\n                    subItem.value.el.parentNode.removeChild(subItem.value.el);\n                    if (this.el) {\n                      this.el.appendChild(subItem.value.el);\n                    }\n                  }\n                }\n                else if (this.el) {\n                  // Need to add it to the DOM\n                  // TODO - this would break the form functionality\n                   this.el.appendChild(subItem.value.dom(jstComponent));\n                }\n              }\n            });\n          }  \n        }\n      });\n      this.contents.splice(oldStartIndex, 0, ...newItems);\n    }\n\n    for (let itemToDelete of itemsToDelete) {\n      this._deleteItem(itemToDelete); \n    } \n  \n    // console.log(\"CAC>\" + \" \".repeat(level*2), \"/\" + this.tag+this.id);\n    return false;\n    \n  }\n\n  _deleteItem(contentsItem) {\n    if (contentsItem.type === JstElementType.JST_ELEMENT) {\n      contentsItem.value.delete();\n    }\n    else if (contentsItem.type === JstElementType.JST_COMPONENT) {\n      contentsItem.value._unrender();\n    }\n    else if (contentsItem.type === JstElementType.TEXTNODE) {\n      if (contentsItem.el && contentsItem.el.parentNode) {\n        contentsItem.el.parentNode.removeChild(contentsItem.el);\n        delete contentsItem.el;\n      }\n    }\n    else {\n      console.warn(\"Unexpected content type while deleting:\", contentsItem.type);\n    }\n  }\n\n  // This is the meat of all of JST - it is what takes a list of arguments to\n  // a jst element (e.g. jst.$div(...)) and converts it into something that represents\n  // a tree of nodes. The passed in params can be a list of lists (will be flattened),\n  // an object (converted to attributes), strings, numbers, booleans (coverted to textnodes)\n  // or other JST objects. If you understand what is going on here, then you really\n  // understand what JST is all about\n  _processParams(params, isUpdate) {\n    params = _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"utils\"]._flatten.apply(this, params);\n    if (typeof params === \"undefined\") {\n      params = [];\n    }\n\n    for (let param of params) {\n      let type = typeof param;\n\n      if (param === null) {\n        // Do nothing\n      }\n      else if (type === \"number\" || type === \"string\") {\n        this.contents.push({type: JstElementType.TEXTNODE, value: param});\n      }\n      else if (type === \"boolean\") {\n        this.contents.push({type: JstElementType.TEXTNODE, value: param.toString()});\n      }\n      else if (param instanceof _jst_component_js__WEBPACK_IMPORTED_MODULE_1__[\"JstComponent\"]) {\n\n        // Put the JstComponent into this element's contents\n        this.contents.push({type: JstElementType.JST_COMPONENT, value: param});\n\n        // Let the JstComponent render itself\n        param.refresh({isParentUpdate: true});\n        \n      }\n      else if (param instanceof JstElement) {\n        param.add();\n        this.contents.push({type: JstElementType.JST_ELEMENT, value: param});\n      }\n      else if (typeof HTMLElement !== 'undefined' && param instanceof HTMLElement) {\n        let jstEl = new JstElement(param);\n        jstEl.add();\n        this.contents.push({type: JstElementType.JST_ELEMENT, value: jstEl});\n      }\n      else if (type === \"object\") {\n        for (let name of Object.keys(param)) {\n          if (typeof(param[name]) === \"undefined\") {\n            param[name] = \"\";\n          }\n          if (name === \"jstoptions\" && param.jstoptions instanceof Object) {\n            this.opts = param.jstoptions;\n          }\n          else if (name === \"properties\" && param.properties instanceof Array) {\n            for (let prop of param.properties) {\n              this.props.push(prop);\n            }\n          }\n          else if (name === \"events\" && typeof param.events === \"object\") {\n            for (let event of Object.keys(param.events)) {\n              if (param.events[event] instanceof Function) {\n                this.events[event] = {listener: param.events[event]};\n              }\n              else {\n                this.events[event] = param.events[event];\n              }\n            }\n          }\n          else if (name === \"ref\") {\n            this.ref       = param[name];\n            this.attrs.ref = param[name];\n          }\n          else if (name === \"cn\") {\n            // A bit of magic for the \"class\" attribute: cn -> class\n            // We also will append to the class if there already is one\n            if (this.attrs['class']) {\n              this.attrs['class'] += \" \" + param[name];\n            }\n            else {\n              this.attrs['class'] = param[name];\n            }\n          }\n          else if (param[name] !== \"\"){\n            this.attrs[name] = param[name];\n          }\n        }\n      }\n      else if (type === \"undefined\") {\n        // skip\n      }\n      else if (param.toString) {\n        this.contents.push({type: JstElementType.TEXTNODE, value: param.toString()});\n      }\n      else {\n        console.warn(\"Unknown JstElement parameter type: \", type);\n      }\n    }\n  }\n\n\n  // This will manage any CSS that should be injected on behalf of\n  // the JstComponent passed in\n  _processCss(jstObj, css) {\n    if (css) {\n      jst.styleManager.updateCss(jstObj, css);\n    }\n  }\n\n\n  // Some helpers\n  _quoteAttrValue(value) {\n    return value.replace ? value.replace(/\"/, '\\\"') : value;\n  }\n\n\n  // This will walk through the contents of this element and\n  // also dive into any component's contents\n  _visitContents(jstComponent, callback) {\n    this.contents.forEach(item => {\n      if (item.type === JstElementType.JST_COMPONENT) {\n        if (item.value._jstEl) {\n\n          // If in debug mode, a <jstcomponent> element surrounds\n          // all JstComponents. In this case, there is no need to\n          // visit a component's contents\n          if (jst.debug) {\n            callback(item.value, item.value._jstEl);\n          }\n          else {\n            item.value._jstEl._visitContents(item.value, callback);\n          }\n          \n        }\n      }\n      else {\n        callback(jstComponent, item);\n      }\n    });\n  }\n  \n\n}\n\n\n//# sourceURL=webpack://jst/./src/jst-element.js?");

/***/ }),

/***/ "./src/jst-form-manager.js":
/*!*********************************!*\
  !*** ./src/jst-form-manager.js ***!
  \*********************************/
/*! exports provided: JstFormManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JstFormManager\", function() { return JstFormManager; });\n\n\n// JstFormManager Class\n//\n// Holds some information about forms\nclass JstFormManager {\n  constructor(jstElement) {\n    this.jstElement = jstElement;\n    this.inputs     = {};\n  }\n\n  addInput(jstElement) {\n    let name = jstElement.attrs.name || jstElement.attrs.id;\n    if (name) {\n      if (this.inputs[name]) {\n        if (Array.isArray(this.inputs[name])) {\n          this.inputs[name].push(jstElement);\n        }\n        else {\n          this.inputs[name] = [this.inputs[name], jstElement];\n        }\n      }\n      else {\n        this.inputs[name] = jstElement;\n      }\n    }\n  }\n\n  setJstElement(jstElement) {\n    this.jstElement = jstElement;\n  }\n\n  getValues() {\n    let vals = {};\n    for (let name of Object.keys(this.inputs)) {\n      if (Array.isArray(this.inputs[name])) {\n        if (this.inputs[name][0].attrs.type &&\n            (this.inputs[name][0].attrs.type.toLowerCase() === \"radio\" ||\n             this.inputs[name][0].attrs.type.toLowerCase() === \"checkbox\")) {\n          for (let input of this.inputs[name]) {\n            if (input.el.checked) {\n              if (typeof input.attrs.value === 'undefined') {\n                vals[name] = input.attrs.id;\n              }\n              else {\n                vals[name] = input.attrs.value;\n              }\n            }\n          }\n        }\n        else {\n          vals[name] = this.inputs[name][0].el.value;\n        }\n      }\n      else {\n        vals[name] = this.inputs[name].el.value;\n      }\n    }\n    return vals;\n  }\n  \n}\n\n\n//# sourceURL=webpack://jst/./src/jst-form-manager.js?");

/***/ }),

/***/ "./src/jst-style-manager.js":
/*!**********************************!*\
  !*** ./src/jst-style-manager.js ***!
  \**********************************/
/*! exports provided: JstStyleManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JstStyleManager\", function() { return JstStyleManager; });\n/* harmony import */ var _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jst-utils.js */ \"./src/jst-utils.js\");\n/* harmony import */ var _jst_component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jst-component.js */ \"./src/jst-component.js\");\n/* harmony import */ var _jst_style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jst-style.js */ \"./src/jst-style.js\");\n\n\n\n\n\n\n\n// JstStyleManager Class\n//\n// This class defines the singletone that manages the set of style elements\n// that are inserted for application created CSS\nclass JstStyleManager extends _jst_component_js__WEBPACK_IMPORTED_MODULE_1__[\"JstComponent\"] {\n  constructor() {\n    super();\n    this.jstStyleLookup = {};\n    this.jstStyles      = [];\n  }\n\n  render() {\n    return this.jstStyles;\n  }\n  \n  updateCss(jstObj, css) {\n    let classPrefix = jstObj.getClassPrefix();\n    let fullPrefix  = jstObj.getFullPrefix();\n\n    let jstStyle    = this.jstStyleLookup[classPrefix];\n\n    let madeNew = false;\n    if (!jstStyle) {\n      jstStyle = new _jst_style_js__WEBPACK_IMPORTED_MODULE_2__[\"JstStyle\"](classPrefix, jstObj.getName());\n      madeNew = true;\n    }\n\n    jstStyle.updateCss(fullPrefix, css);\n\n    if (madeNew) {\n      this._addStyle(jstStyle, classPrefix);\n    }\n    else {\n      jstStyle.refresh();\n    }\n    \n  }\n\n  removeCss(jstObj) {\n    let classPrefix = jstObj.getClassPrefix();\n    let fullPrefix  = jstObj.getFullPrefix();\n\n    let jstStyle    = this.jstStyleLookup[classPrefix];\n\n    if (jstStyle) {\n      jstStyle.removeCss(fullPrefix);\n      this._removeStyle(jstStyle, classPrefix);\n    }\n  }\n\n  _addStyle(jstStyle, classPrefix) {\n    this.jstStyles.push(jstStyle);\n    this.jstStyleLookup[classPrefix] = jstStyle;\n    this.refresh();\n  }\n\n  _removeStyle(jstStyle, classPrefix) {\n    // TODO - need some sort of ref counting of\n    // users of local styles so they can be removed\n    // when last user is gone\n    return;\n    let index = 0;\n    for (let entry of this.jstStyles) {\n      if (jstStyle === entry) {\n        this.jstStyles.splice(index, 1);\n        delete(this.jstStyleLookup[classPrefix]);\n        break;\n      }\n      index++;\n    }\n    this.refresh();\n  }\n\n}\n\n\n\n\n//# sourceURL=webpack://jst/./src/jst-style-manager.js?");

/***/ }),

/***/ "./src/jst-style.js":
/*!**************************!*\
  !*** ./src/jst-style.js ***!
  \**************************/
/*! exports provided: JstStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JstStyle\", function() { return JstStyle; });\n/* harmony import */ var _jst_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jst-utils.js */ \"./src/jst-utils.js\");\n/* harmony import */ var _jst_component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jst-component.js */ \"./src/jst-component.js\");\n// jst-style - contains implementation of the rendering of CSS\n// for JstComponents\n//\n// Copyright 2018 Edward Funnekotter All rights reserved\n\n\n\n\nlet jst;\n\n// JstStyle Class\n//\n// This renders a single style block\nclass JstStyle extends _jst_component_js__WEBPACK_IMPORTED_MODULE_1__[\"JstComponent\"] {\n  static init(initJst) {\n    jst = initJst;\n  }\n  \n  constructor(classPrefix, className) {\n    super();\n    this.classPrefix = classPrefix;\n    this.className   = className;\n    this.css         = {\n      cssGlobal:   [],\n      cssLocal:    [],\n      cssInstance: {}\n    };\n  }\n\n  updateCss(fullPrefix, css) {\n    let processedCss = this._processCss(fullPrefix, css);\n    this.css.cssGlobal = processedCss.cssGlobal;\n    this.css.cssLocal  = processedCss.cssLocal;\n\n    if (!this.css.cssInstance) {\n      this.css.cssInstance = {};\n    }\n    this.css.cssInstance[fullPrefix] = processedCss.cssInstance;\n    this.refresh();\n  }\n\n  removeCss(fullPrefix) {\n    if (this.css.cssInstance[fullPrefix]) {\n      delete(this.css.cssInstance[fullPrefix]);\n      this.refresh();\n    }\n  }\n\n  // Render the <style> tag\n  render() {\n    return [\"cssGlobal\", \"cssLocal\", \"cssInstance\"].map(\n      type => {\n        if (this.css && this.css[type]) {\n          if (type === \"cssInstance\") {\n            return Object.values(this.css.cssInstance).map(\n              instance => instance.map(item => jst.$style(item)));\n          }\n          else {\n            return this.css[type].map(item => {\n              return jst.$style(item);\n            });\n          }\n        }\n        return undefined;\n      }\n    );\n  }\n\n  // Override the type to put more useful info\n  getType() {\n    return `${this.getName()}-${this.className}`;\n  }\n\n  // Go through the new CSS and either update existing CSS or\n  // replace what is there, if changed \n  _processCss(fullPrefix, css) {\n    let processedCss = {};\n    for (let typeInfo of [\n      [\"cssGlobal\"               ],\n      [\"cssLocal\",    this.classPrefix],\n      [\"cssInstance\", fullPrefix ]\n    ]) {\n      let type   = typeInfo[0];\n      let prefix = typeInfo[1];\n\n      processedCss[type] = [];\n      \n      if (css[type]) {\n        for (let block of css[type]) {\n          if (block) {\n            processedCss[type].push(this._stringify(prefix, block));\n          }\n        }\n      }\n    }\n    return processedCss;\n  }\n\n  // Stringify the CSS into blocks suitable for insertion into the DOM\n  _stringify(prefix, block) {\n    let text = \"\";\n    for(let selector of Object.keys(block)) {\n      let atRuleRule;\n      if (selector.match(/^@/)) {\n        atRuleRule = block[selector][\":rule\"];\n        delete(block[selector][\":rule\"]);\n      }\n      \n      let rules = block[selector];\n      if (typeof(atRuleRule) != \"undefined\") {\n        text += `${selector} ${atRuleRule} {\\n`;\n        text += this._stringify(prefix, rules);\n        text += `}\\n`;\n      }\n      else {\n        let scopedSelector = prefix ? selector.replace(/([\\.#])/g, `$1${prefix}`) : selector;\n        text += `${scopedSelector} `;\n        text += this._stringifyObj(rules, \"\");\n      }\n    }\n    return text;\n  }\n\n  // Stringify a basic javascript object into CSS\n  _stringifyObj(obj, indent) {\n    if (!(obj instanceof Object)) {\n      if (typeof obj !== \"undefined\" && obj.toString) {\n        return obj.toString();\n      }\n      else {\n        return \"\";\n      }\n    }\n    let text = \"{\\n\";\n    for (let prop of Object.keys(obj)) {\n      let val = obj[prop];\n      let attr = prop.replace(/([A-Z])/g, m => \"-\"+m.toLowerCase());\n      val = val.reduce ? val.reduce((acc, item) =>\n                                    acc + \" \" + this._stringifyObj(item, indent + \"  \"), \"\") :\n        val.rgbaString ? val.rgbaString : val.toString();\n      val = val.replace(/\\s+/, \" \");\n      if (val.substr(-2,1) !== \"}\") {\n      text += `${indent}  ${attr}: ${val};\\n`;\n      }\n      else {\n        text += `${indent}  ${attr} ${val}`;\n      }\n    }\n    text += `${indent}}\\n`;\n    return text;\n  }\n  \n}\n\n\n//# sourceURL=webpack://jst/./src/jst-style.js?");

/***/ }),

/***/ "./src/jst-utils.js":
/*!**************************!*\
  !*** ./src/jst-utils.js ***!
  \**************************/
/*! exports provided: utils, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"utils\", function() { return utils; });\n\n\nlet utils = {\n  _flatten: function() {\n    var flat = [];\n    for (var i = 0; i < arguments.length; i++) {\n      if (arguments[i] instanceof Array) {\n        flat.push.apply(flat, utils._flatten.apply(this, arguments[i]));\n      }\n      else if (arguments[i] instanceof Function) {\n        let result = arguments[i]();\n        if (result instanceof Array) {\n          flat.push.apply(flat, utils._flatten.apply(this, result));\n        }\n        else {\n          flat.push(result);\n        }\n      }\n      else {\n        flat.push(arguments[i]);\n      }\n    }\n    return flat;\n  },\n  \n\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (utils);\n\n\n//# sourceURL=webpack://jst/./src/jst-utils.js?");

/***/ })

/******/ });